"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useBlock = exports.useStarknetBlock = void 0;
const react_query_1 = require("@tanstack/react-query");
const providers_1 = require("../providers");
/**
 * Hook for fetching a block.
 *
 * @remarks
 *
 * This hook fetches the `latest` block using the default provider.
 * Block data is continuously refreshed in the background.
 *
 * @deprecated Use {@link useBlock}.
 *
 * @example
 * This example shows how to fetch the latest block.
 * ```tsx
 * function Component() {
 *   const { data, loading, error } = useStarknetBlock()
 *
 *   if (loading) return <span>Loading...</span>
 *   if (error) return <span>Error...</span>
 *   return <span>Hash: {data.block_hash}</span>
 * }
 * ```
 */
function useStarknetBlock() {
    const { data, isLoading, isError } = useBlock({
        blockIdentifier: 'latest',
    });
    return {
        data,
        loading: isLoading,
        error: isError ? 'error loading block number' : undefined,
    };
}
exports.useStarknetBlock = useStarknetBlock;
/**
 * Hook for fetching a block.
 *
 * @remarks
 *
 * Specify which block to fetch with the `blockIdentifier` argument.
 * Control if and how often data is refreshed with `refetchInterval`.
 *
 * @example
 * This example shows how to fetch the latest block only once.
 * ```tsx
 * function Component() {
 *   const { data, isLoading, isError } = useBlock({
 *     refetchInterval: false,
 *     blockIdentifier: 'latest'
 *   })
 *
 *   if (isLoading) return <span>Loading...</span>
 *   if (isError) return <span>Error...</span>
 *   return <span>Hash: {data.block_hash}</span>
 * }
 * ```
 *
 * @example
 * This example shows how to fetch the pending block every 3 seconds.
 * Use your browser network monitor to verify that the hook is refetching the
 * data.
 * ```tsx
 * function Component() {
 *   const { data, isLoading, isError } = useBlock({
 *     refetchInterval: 3000,
 *     blockIdentifier: 'pending'
 *   })
 *
 *   if (isLoading) return <span>Loading...</span>
 *   if (isError) return <span>Error...</span>
 *   return <span>Hash: {data.block_hash}</span>
 * }
 * ```
 */
function useBlock({ refetchInterval, onSuccess, blockIdentifier = 'latest', } = {}) {
    const { library } = (0, providers_1.useStarknet)();
    const { data, isLoading, isError, error } = (0, react_query_1.useQuery)(['block', blockIdentifier], fetchBlock({ library, args: { blockIdentifier } }), {
        refetchInterval,
        useErrorBoundary: true,
        onSuccess: (block) => {
            if (block && onSuccess)
                onSuccess(block);
        },
    });
    return { data, isLoading, isError, error };
}
exports.useBlock = useBlock;
function fetchBlock({ library, args, }) {
    return async () => {
        return await library.getBlock(args.blockIdentifier);
    };
}
//# sourceMappingURL=block.js.map