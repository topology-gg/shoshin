"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useTransactions = exports.useTransaction = void 0;
const react_query_1 = require("@tanstack/react-query");
const providers_1 = require("../providers");
/**
 * Hook to fetch a single transaction.
 *
 * @remarks
 *
 * This hook keeps a cache of transactions by chain and transaction hash
 * so that you can use the hook freely in your application without worrying
 * about sending duplicate network requests.
 *
 * @example
 * This hook shows how to fetch a transaction.
 * ```tsx
 * function Component() {
 *   const { data, loading, error } = useTransaction({ hash: txHash })
 *
 *   if (loading) return <span>Loading...</span>
 *   if (error) return <span>Error: {JSON.stringify(error)}</span>
 *   return <span>{data.transaction_hash}</span>
 * }
 */
function useTransaction({ hash }) {
    const { library } = (0, providers_1.useStarknet)();
    const { data, isLoading, error } = (0, react_query_1.useQuery)(queryKey({ library, hash }), fetchTransaction({ library, hash }));
    return { data, loading: isLoading, error: error ?? undefined };
}
exports.useTransaction = useTransaction;
/**
 * Hook to fetch a list of transactions in parallel.
 *
 * @remarks
 *
 * This hook fetches a dynamic list of transactions without
 * violating the rules of hooks.
 *
 * @example
 * This example shows how to fetch a list of transactions.
 * ```tsx
 * function Component() {
 *   const results = useTransactions({
 *     hashes: [txHash, txHash2]
 *   })
 *
 *   return (
 *     <ul>
 *       {results.map(({ data }, i) => (
 *         <li key={i}>
 *         {data ? data.transaction_hash : 'Loading...'}
 *         </li>
 *       ))}
 *     </ul>
 *   )
 * }
 * ```
 */
function useTransactions({ hashes }) {
    const { library } = (0, providers_1.useStarknet)();
    const result = (0, react_query_1.useQueries)({
        queries: hashes.map((hash) => ({
            queryKey: queryKey({ library, hash }),
            queryFn: fetchTransaction({ library, hash }),
        })),
    });
    return result.map(({ data, isLoading, error }) => ({
        data,
        loading: isLoading,
        error: error ?? undefined,
    }));
}
exports.useTransactions = useTransactions;
function queryKey({ library, hash }) {
    return [
        {
            entity: 'transaction',
            chainId: library.chainId,
            hash: hash,
        },
    ];
}
function fetchTransaction({ library, hash }) {
    return async () => {
        if (!hash)
            throw new Error('hash is required');
        return await library.getTransaction(hash);
    };
}
//# sourceMappingURL=transaction.js.map